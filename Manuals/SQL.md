# SQL

**Реляционная база данных** состоит из двумерных таблиц *(строка и столбец)* информации.  
**Строки** таблицы называются **записями**.  
**Столбцы (fields)** таблицы называются **полями**. Они именуются и упорядочиваются.  
**Первичные ключи (primary key)** - уникальные идентификаторы каждой записи таблицы *(уникальный столбец или группа столбцов)*.  
**Предикат** - условие определяемое **WHERE**, которое может быть верным или неверным для любой строки таблицы.  
**DDL (Язык Определения Данных)** - так называемый Язык Описания Схемы в ANSI, состоит из команд которые создают объекты 
( таблицы, индексы, просмотры, и так далее ) в базе данных.  
**DML (Язык Манипулирования Данными)** - это набор команд которые определяют какие значения представлены в таблицах в любой момент времени.  
**DCD (Язык Управления Данными)** - состоит из средств которые определяют, разрешить ли пользователю выполнять определенные действия или нет.  
*Интерактивный SQL* используется для выполнения действий в базе данный, а *Встроеннный SQL*в различных языках программирования для обращений к базе данных.
***
Основные типы данных, определенные в ANSI:
* **INTEGER (INT)** - целое чило  
* **DECIMAL (DEC)** - вещественное число   
* **DATA** - дата
* **CHAR** - строка текста. Поле типа CHAR имеет определенную длину, которая определяется максимальным числом символов которые могут быть введены в это поле.  
* **VARCHAR** - является текстовой строкой которая может иметь любую длину до определенного реализацией максимума (обычно 254 символа ).  
*CHARACTER* и *VARCHAR* значения включаются в одиночные кавычки как например **'текст'**. Различие между *CHAR* и *VARCHAR* в том, что *CHAR* должен резервировать достаточное 
количество памяти для максимальной длины строки, а *VARCHAR* выделяет память по мере необходимости.
***
Специальное значение **USER** может использоваться как аргумент в команде. Он
обозначает авторизационный ID пользователя, дающего команду.  
***
Все запросы в SQL конструируются вокруг одной команды - **SELECT**.  

**SELECT** *sname1*, *sname2* **FROM** *table*;  
* **SELECT** - ключевое слово, которое сообщает базе данных, что команда является запросом.  
* ***sname*** - список столбцов, которые должны быть предоставлены по выполнению запроса.  
* **FROM** - ключевое слово, которое должно быть представлено в каждом запросе.
За ним следует имя таблицы, которая используется как источник информации для запроса.  
* **;** - используется во всех интерактивных командах SQL для сообщения базе данных, что команда
сформулирована и готова к выполнению. В некоторых системах этот символ заменен на символ "слэш обратный" ("\\") в строке,
которая непосредственно следует за концом команды.  
***
**SELECT** __*__ **FROM** *table*; - вывести все столбцы таблицы.  
***
**SELECT** **DISTINCT** __*__ **FROM** *table*;
* **DISTINCT** - исключает дублирующиеся значения строк из списка выходных данных.  
* **ALL** - наоборот включает дублирующиеся результаты в список. По умолчанию считается, что стоит **ALL**
***
**SELECT** *sname* **FROM** *table* **WHERE** *sname*='city';
* **WHERE** определяет *предикат* - условие, которое может быть истинным или ложным для каждой строки.  
* **AND, OR, NOT** - могут использоваться в условиях   

***
## Специальные операторы.  

Вместо подобного перечисления условий:  
**SELECT** __*__ **FROM** *table* **WHERE** *city*='London' **OR** *city*='Barcelona';  
Можно использовать следующий вариант:  
**SELECT** __*__ **FROM** *table* **WHERE** *city* **IN** ('London', 'Barcelona');  
* **IN** полностью определяет множество, которому данное значение может принадлежать или не принадлежать.
Выполняется, если значение равно хотя бы одному элементу множества.  
***
**SELECT** __*__ **FROM** *table* **WHERE** *snum* **BETWEEN** 4 **AND** 8;  
* **BETWEEN** ... **AND**... - задает границы, в которые должно попадать значение. Границы включены.
В нем можно указывать диапазон чисел или букв (алфавитный диапазон, у него не попадают крайние элементы).  
***
**SELECT** __*__ **FROM** *table* **WHERE** (*sum* **BETWEEN** 7 **AND** 10) 
**AND** **NOT** *sum* **IN** (7, 10) - исключающее множество, в которое не входят границы.  
***
 **LIKE** применим только к полям типа **CHAR** или **VARCHAR**, поскольку он используется для поиска подстрок. Он осуществляет просмотр строки для
выяснения: входит ли заданная подстрока в указанное поле. С этой же целью используются шаблоны - специальные 
символы, которые могут обозначать все, что угодно.  
Существует два типа шаблонов, используемых с **LIКE**:  
* Символ "подчеркивание" ( **_** ) заменяет один любой символ. Например, образцу
'b_t' соответствуют 'bаt' или 'bit', но не соответствует 'brat'. 
* Символ "процент" ( **%** ) заменяет последовательность символов произвольной
длины, в том числе и нулевой. Например, образцу '%p%t' соответствуют 'put',
'posit', 'opt', но не 'spite'.  
**LIКE** может оказаться полезным при осуществлении поиска имени или другого
значения, полное написание которого неизвестно.  

**SELECT** __*__ **FROM** *table* **WHERE** *sname* **LIKE** 'G%';  

***
Специальные операторы (**IS**, **LIKE**, **BEETWEN**, **IN**, **LIKE**) могут непосредственно предшествовать булеву оператору 
**NOT**. Этим они отличаются от операторов сравнения, которые должны содержать **NOT** перед всем выражением.  

**SELECT** __*__ **FROM** *Customers* **WHERE** *city* **IS NOT NULL;**  
Эквивалентно следующему:  
**SELECT** __*__ **FROM** *Customers* **WHERE** **NOT** *city* **IS NULL;**  

**SELECT** __*__ **FROM** *Salespeople* **WHERE** *city* **NOT IN** (*'London', ·san Jose'*);  
<=>  
**SELECT** __*__ **FROM** *Salespeople* **WHERE** **NOT** *city* **IN** (*'London' , 'San Jose'*);  

***

Символ шаблона **(%)** в конце строки необходим в тех реализациях SQL, в которых длина поля sname пре­восходит количество 
букв в значении (например тип **CHAR**, где фиксированная длина строки). В этих случаях к значению в таблице добавляются 
пробелы до длины строки. 
***
Чтобы найти в строке символ подчеркивания или процента, в предикате **LIKE** любой символ можно определить как **Еsсаре-символ**. 
Он используется в предикате непо­средственно перед символом процента или подчеркивания и означает, что следующий за ним 
символ интерпретируется именно как обычный символ, а не как символ шаблона.  

**SELECT** __*__ **FROM** *table* **WHERE** *sname* **LIKE** '%/_%' **ESCAPE** '/';
  
 Предложение **ESCAPE** определяет **'/'** как Еsсаре-символ, который используется в **LIКЕ**-строке, за ним следуют
 символ процента, символ подчеркивания или сам символ **'/'**, т.е. тот символ, поиск которо­го будет осуществляться в 
 столбце и который уже не интерпретируется как символ шаблона. **Еsсаре-символ** может быть единственным символом и 
 применяться только к единственному символу, который следует за ним.  
 ***
 **NULL** - пустое значение (поле) в строке (записи).  
 Когда **NULL-значение** сравнивается с любым значением, даже с **NULL-значением**, результат просто неизвестен. 
 Булево значение "неизвестно" ведет себя также, как "ложь" - строка, на которой предикат принимает значение "неизвестно",
 не включается в результат запроса - при одном важном исключении: **NOT** от лжи есть истина (**NOT (false)=true**), 
 тогда как **NOT** от неизвестного значения есть также неизвестное значение. Следовательно, такое выраже­ние как 
 **"city = NULL"** или **"city IN (NULL)"** является неизвестным независимо от значения city.  
 
 **IS** - используется с ключевым словом **NULL** для локализации **NULL-значения**.
   
 **SELECT** __*__ **FROM** *table* **WHERE** *city* **IS** **NULL**;  
 
***
 
 ## Функции агрегирования.  
 
* **COUNT** определяет количество строк или значений поля, выбранных посредством запроса и не являющихся **NULL**-значениями.
* **SUM** вычисляет арифметическую сумму всех выбранных значений данного
поля.
* **АVG** вычисляет среднее значение для всех выбранных значений данного поля.
* **МАХ** вычисляет наибольшее из всех выбранных значений данного поля.
* **MIN** вычисляет наименьшее из всех выбранных значений данного поля.  

Функции агрегирования используются как имена полей в предложении запроса **SELECT** с одним исключением: имена полей 
применяются как аргументы.  
Для **SUM** и **AVG** могут использоваться только цифровые поля. Для **COUNT, МАХ** и **MIN** - цифровые и символьные поля.  
***
Сумма всех заявок из таблицы *Orders*:  
**SELECT SUM**(*amt*) **FROM** *Orders*;  

***
 Функция **COUNT** отличается от предыдущих тем, что подсчитывает количество значений в данном столбце или количество 
 строк в таблице. Когда подсчитываются значения по столбцу, в команде используется **DISTINCT** для подсчета числа 
 различных значений данного поля.  
 
 **SELECT** **COUNT** (**DISTINCT** *snum*) **FROM** *Orders*;  
 
 **DISТINCT** можно применять с любой функцией агрегирования, но чаще всего он используется с **COUNT**.  
 Для подсчета общего количества строк в таблице следует использовать функцию **COUNT** со звездочкой вместо имени поля.  
 
 **SELECT** **COUNT** (__*__) **FROM** *Customers*; - подсчет общего количества строк в таблице *Customers*.  

Различие между **ALL** и __*__ при использовании **COUNT** заключается в следующем:
* **ALL** использует имя поля в качестве аргумента.
* **ALL** не подсчитывает **NULL**-значения.  
 
**SELECT COUNT** (**ALL** *rating*) **FROM** *Customers*; - подсчет количества значений поля *rating*, отличных от 
**NULL**-значений, в таблице *Customers* (включая повторения).  

***
Агрегатные функции можно использовать с аргементами, состоящими из нескольких полей:  

**SELECT МАХ** (*binc + amt*) **FROM** *Orders*;  

***
**GROUP BY** группирует по полям, имеющим одинаковые значения.

**SELECT** *snum*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum*; -  наибольший заказ из тех, что получил каждый 
из продавцов.

**GROUP BY** применяет агрегатные функции отдельно к каждой серии групп, которые определяются общим значением поля. 
В данном случае каждая группа состоит из всех тех строк, которые имеют одно и то же значение *snum*, а функция **МАХ** 
применяется отдельно к каждой такой группе. Это означает, что поле, к которому применяется
**GROUP BY** по определению имеет на выходе только одно значение на каждую группу, что соответствует применению 
агрегатных функций.  

**Двойная группировка**: группировка данных таблицы *Orders* по дате (*odate*) внутри одного и того же поля **snum** и применить функцию **МАХ**
к каждой группе.  
   
 **SELECT** *snum*, *odate*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum*, *odate*;  
 
***
 
Использовать *агрегатные функции* в предложении **WHERE** **нельзя** поскольку предикаты оцениваются в терминах единственной
строки, тогда как агрегатные функции оцениваются в терминах групп строк.  

Покупки превышающие 3000 сгруппированные по датам у сгруппированных продавцов:  
**! ! ! НЕЛЬЗЯ! ! !:**  
**SELECT** *snum, odate*, **MAX**(*amt*) **FROM** *Orders* **WHERE MAX**(*amt*) > 3000.00 **GROUP ВY** *snum, odate*;  

***! ! ! МОЖНО ! ! !:**  
**SELECT** *snum, odate*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum, odate* **HAVING MAX**(*amt*) > 3000.00;  

* **HAVING** -  определяет критерий, согласно которому определенные группы исключаются из числа выходных данных, так же,
как предложение **WHERE** делает это для отдельных строк. Аргументы **HAVING** подчиняются тем же правилам, что и 
аргументы **SELECT** в команде, использующей **GROUP ВY**, и должны иметь единственное значение для каждой выходной группы.   
**HAVING** должно относиться только к агрегатам и полям, выбранным по **GROUP ВY**.  

"Вот наибольшие заявки на 3 октября":  
**SELECT** *snum*, **MAX**(*amt*) **FROM** *Orders* **WHERE** *odate* = 10/03/1990
**GROUP BY** *snum*;  

**HAVING** может иметь только такие аргументы, у которых единственное значение для группы выходных данных. На практике 
чаще всего применяются агрегатные функции, но можно осуществлять выбор полей и с помощью **GROUP ВY**. Например, можно 
взглянуть на самые большие заказы для Serres и Rifkin:  

**SELECT** *snum*, **MAX**(*amt*)  
**FROM** *Orders*  
**GROUP ВY** *snum*  
**HAVING** *snum* **IN** (1002, 1007)  

Агрегатные функции применимы к группам значений, определяемым предложением **GROUP ВY**. Эти группы имеют общее значение
поля и могут использоваться внутри других групп, имеющих общее значение поля. Предикаты нужны для определения строк, 
к которым применяется функция агрегирования. Вы можете задать условие исключения определенных результирующих
групп с помощью предложения **HAVING**.  

***
Все заявки от 10 марта 1990:  

**SELECT** **COUNT** ( __*__ )  
**FROM** *Orders*  
**WHERE** *odate* = 10/03/1990;  

***
Количество различных городов (не **NULL**) в таблице *Customers*:
  
**SELECT COUNT** (**DISTINCT** *city*)  
**FROM** *Customers*;  

***
Запрос, который выбирает первого в алфавитном порядке покупателя, имя которого начинается с 'G':

**SELECT MIN** (*cname*)  
**FROM** *Customers*  
**WHERE** *cname* **LIKE** 'G%';   

***
Запрос, который выбирает максимальный рейтинг (rating) для каждого города:  

**SELECT** *city*, **МАХ** (*rating*)  
**FROM** *Customers*  
**GROUP ВY** *city*;  
  
***
Вставка текста в новые столбцы в каждую строку выходной таблицы:  

**SELECT** 'Fог', *odate*, 'there аге',  
**COUNT** (**DISTINCT** *onum*), 'orders'  
**FROM** *Orders*  
**GROUP ВY** *odate*;  

***

### Упорядочивание выходных полей  

**SELECT** __*__  
**FROM** *Orders*  
**ORDER ВY** *cnum* **DESC**;  

* **ORDER BY** - упорядочивает в соответствии со значениями одного
или нескольких выбранных столбцов.  
    * **DESC** - убывающая сортировка.
    * **ASC** - возрастающая сортировка.  
 
 **ORDER BY** применяется только для столбцов, указанных в **SELECT**.  
 Её можно применять для любого количества столбцов:  
 
**SELECT** __*__  
**FROM** *Orders*  
**ORDER ВY** *cnum* **DESC**, *amt* **DESC**;  

**OREDRD BY** всегда выполняется последней.  

Вместо имен столбцов для указания полей, по которым упорядочиваются выходные данные, можно использовать номера. 
Но ссылаясь на них, следует иметь в виду, что это номера в определении выходных данных, а не столбцов в таблице. 
Т.е. первое поле, имя которого указано в **SELECT**, является для предложения **ORDER ВY** полем с
номером **1**, независимо от его расположения в таблице.  
Столбцы, полученные с помощью функций агрегирования, константы или выражения в предложении запроса **SELECT**, можно 
применить и с **ORDER ВY**, если на них ссылаются по номеру.  

***

## Соединение таблиц.  

### Выполнение операции соединения (join)

**SELECT** *Customers.cname, Salespeople.sname, Salespeople.city*  
**FROM** *Salespeople, Customers*  
**WHERE** *Salespeople.city = Customers.city*;  

Выполняя операцию соединения, необходимо генерировать все возможные сочетания
строк для двух или более таблиц и проверять истинность предиката на каждом таком
сочетании.  
В предыдущем примере **SQL** берет строку, соответствующую продавцу *Рееl* из таблицы *Salespeople*, и комбинирует ее 
с каждой строкой таблицы *Customers*, выбирая по одной строке из этой таблицы. Если на данной комбинации
строк предикат имеет значение "истинно", т.е. поле *city* строки таблицы Customers содержит
значение *London* такое же, как и у *Рееl*, то указанные в предложении **SELECT**
поля из комбинации этих строк являются выходными данными. Те же действия предпринимаются
относительно каждого продавца из таблицы *Salespeople*.  

### Операция соединения таблиц посредством ссылочной целостности  

Эrа операция применяется для использования связей, встроенных в базу данных. В предыдущем примере связь между таблицами 
была установлена с помощью операции соединения. Но эти таблицы уже связаны по значениям полем *snum*(присутствует в 
обеих таблицах). Такая связь называется *состоянием ссылочной целостности*. Стандартное применение операции соединения 
состоит в извлечении данных в терминах этой связи. Чтобы показать соответствие имен покупателей именам продавцов, 
обслуживающих этих покупателей, используется следующий запрос:  

**SELECT** *Customers.cname, Salespeople.sname*  
**FROM** *Customers, Salespeople*  
**WHERE** *Salespeople.snum = Customers.snum*;  

***

### Как выполняется операция соединения двух копий одной таблицы

Соединение таблицы с ее же копией означает следующее: любую строку таблицы (одну в каждый момент времени) можно 
комбинировать с ее копией и с любой другой строкой этой же таблицы. Каждая такая комбинация оценивается в терминах 
предиката, как и в случае соединения нескольких различных таблиц. Это позволяет легко конструировать определенные виды 
связей между различными записями внутри единственной таблицы - например, осуществлять поиск пар строк с общим значением 
поля.  

Синтаксис команды соединения таблицы с ее же копией тот же, что и для различных
таблиц, с единственным исключением. В рассматриваемом случае все имена
столбцов повторяются независимо от использования имени таблицы в качестве префикса.
Чтобы сослаться на столбцы запроса, нужно иметь два различных имени для
одной и той же таблицы. Для этого надо определить временные имена, называемые
*переменными области определения, переменными корреляции* или просто *алиасами*.
Они определяются в предложении запроса **FROM**. Для этого указывается имя таблицы,
ставится пробел, а затем указывается имя алиаса для данной таблицы.  

**SELECT** *first.cname, second.cname, first.rating*  
**FROM** *Customers first, Customers second*  
**WHERE** *first.rating = second.rating*;  

В данном примере задвоятся строки вывода, т.к. сначала будет для одной таблицы, затем для второй. Самое простое 
решение - это добавить операцию сравнения имен в алфавитном порядке(в одном из проходов по таблицам оно будет ложью):  

**SELECT** *first.cname, second.cname, first.rating*  
**FROM** *Customers first, Customers second*  
**WHERE** *first.rating = second.rating* **AND** *first.cname < second.cname*;  

***

### Вложенные запросы

Выбор всех заказов из таблицы *Orders* у определенного продавца. 
Известно только его имя 'Motika', но не *snum*. Поэтому подзапросом сопоставляем имя и 
*snum* в другой таблице:  

**SELECT** __*__  
**FROM** *Orders*  
**WHERE** *snum* =  
 (**SELECT** *snum* **FROM** *Salespeople* **WHERE** *sname* = 'Motika');  
 
 В случае оператора равенства в предикате, подзапрос должен возращать только одно значение. 
 В других случаях он будет признан *UNKNOWN* или ошибочным.  
 
 В некоторых случаях можно использовать **DISTINCT** для гарантии получения единственного значения в результате 
 выполнения подзапроса. Предположим, нужно найти все заказы (*orders*), с которыми работает продавец, обслуживающий 
 покупателя Hoffman (*cnum = 2001*). В подзапросе вычисляем продавца, который работает с данным покупателем, убираем 
 возможные дубликаты и передаем в основной запрос:  
 
**SELECT** __*__   
**FROM** *Orders*  
**WHERE** *snum* =  
(**SELECT** **DISTINCT** *snum* **FROM** *Orders* **WHERE** *cnum* = 2001); 
 
Предикаты, включающие подзапросы, используют форму <скалярное выражение> <оператор> <подзапрос>, а не <подзапрос>
 <оператор> <скалярное выражение> или <подзапрос> <оператор> <подзапрос>. Согласно ограничению ANSI запрещен также 
 вариант команды, в котором оба значения, участвующие в сравнении, получаются в результате выполнения подзапросов.  
 
 В подзапросах нельзя использовать **GROUP BY**, т.к. оно по умолчанию должно возвращать не единственное значение. 
 Соглашение ANSI запрещает его использовние даже с **HAVE**.  
 
 Операторы **BEETWEN, LIKE, IS NULL** в подзапросах тоже нельзя применять.  
 
 Оператор **IN** можно использовать в подзапросах. Когда **IN** применяется в подзапросе, **SQL** просто строит 
 множество значений из выходных данных подзапроса.  
 
 ***
 
 ### Подзапросы с HAVING
 Подзапросы можно применять также внутри предложения **HAVING**. В самих таких подзапросах можно использовать их 
 собственные агрегатные функции, если они не дают множества значений, а также **GROUP ВY** или **HAVING**.  

Поиск покупателей (customers) с рейтингом (raiting), превышающим среднее значение для San Jose:  
 
**SELECT** *rating*, **COUNT** (**DISTINCT** *cnum*)  
**FROM** *Customers*  
**GROUP ВY** *rating* **HAVING** *rating* >  
(**SELECT** **AVG** (*rating*) **FROM** *Customers* **WHERE** *city* = 'San Jose');  
  
 ***
 
 Запрос, который выдает имена и рейтинги всех тех покупателей, кото­рые сделали больше среднего числа заказов.  
 
 **SELECT** **DISTINCT** *cname*, *rating*  
 **FROM** *Customers*, *Orders*  
 **WHERE** *amt* >  
(**SELECT** **AVG** (*amt*) **FROM** *Ordeгs*)  
 **AND** *Orders.cnum = Customers.cnum*;  
 
 ***
 
Запрос, выбирающий сумму заказов каждого продавца, у которого она превышает наибольшее значение поля *amt* в 
таблице *Orders*.  

 **SELECT** *snum*, **SUM** (*amt*)  
 **FROM** *Orders*  
 **GROUP ВY** *snum*  **HAVING** **SUM** (*amt*) >  
 (**SELECT** **МАХ** (*amt*) **FROM** *Orders*);  
 
 ***
 
 