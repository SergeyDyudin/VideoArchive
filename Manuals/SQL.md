# SQL

**Реляционная база данных** состоит из двумерных таблиц *(строка и столбец)* информации.  
**Строки** таблицы называются **записями**.  
**Столбцы (fields)** таблицы называются **полями**. Они именуются и упорядочиваются.  
**Первичные ключи (primary key)** - уникальные идентификаторы каждой записи таблицы *(уникальный столбец или группа столбцов)*.  
**Предикат** - условие определяемое **WHERE**, которое может быть верным или неверным для любой строки таблицы.  
**DDL (Язык Определения Данных)** - так называемый Язык Описания Схемы в ANSI, состоит из команд которые создают объекты 
( таблицы, индексы, просмотры, и так далее ) в базе данных.  
**DML (Язык Манипулирования Данными)** - это набор команд которые определяют какие значения представлены в таблицах в любой момент времени.  
**DCD (Язык Управления Данными)** - состоит из средств которые определяют, разрешить ли пользователю выполнять определенные действия или нет.  
*Интерактивный SQL* используется для выполнения действий в базе данный, а *Встроеннный SQL*в различных языках программирования для обращений к базе данных.
***
Основные типы данных, определенные в ANSI:
* **INTEGER (INT)** - целое чило  
* **DECIMAL (DEC)** - вещественное число   
* **DATA** - дата
* **CHAR** - строка текста. Поле типа CHAR имеет определенную длину, которая определяется максимальным числом символов которые могут быть введены в это поле.  
* **VARCHAR** - является текстовой строкой которая может иметь любую длину до определенного реализацией максимума (обычно 254 символа ).  
*CHARACTER* и *VARCHAR* значения включаются в одиночные кавычки как например **'текст'**. Различие между *CHAR* и *VARCHAR* в том, что *CHAR* должен резервировать достаточное 
количество памяти для максимальной длины строки, а *VARCHAR* выделяет память по мере необходимости.
***
Специальное значение **USER** может использоваться как аргумент в команде. Он
обозначает авторизационный ID пользователя, дающего команду.  
***
Все запросы в SQL конструируются вокруг одной команды - **SELECT**.  

**SELECT** *sname1*, *sname2* **FROM** *table*;  
* **SELECT** - ключевое слово, которое сообщает базе данных, что команда является запросом.  
* ***sname*** - список столбцов, которые должны быть предоставлены по выполнению запроса.  
* **FROM** - ключевое слово, которое должно быть представлено в каждом запросе.
За ним следует имя таблицы, которая используется как источник информации для запроса.  
* **;** - используется во всех интерактивных командах SQL для сообщения базе данных, что команда
сформулирована и готова к выполнению. В некоторых системах этот символ заменен на символ "слэш обратный" ("\\") в строке,
которая непосредственно следует за концом команды.  
***
**SELECT** __*__ **FROM** *table*; - вывести все столбцы таблицы.  
***
**SELECT** **DISTINCT** __*__ **FROM** *table*;
* **DISTINCT** - исключает дублирующиеся значения строк из списка выходных данных.  
* **ALL** - наоборот включает дублирующиеся результаты в список. По умолчанию считается, что стоит **ALL**
***
**SELECT** *sname* **FROM** *table* **WHERE** *sname*='city';
* **WHERE** определяет *предикат* - условие, которое может быть истинным или ложным для каждой строки.  
* **AND, OR, NOT** - могут использоваться в условиях   

***
## Специальные операторы.  

Вместо подобного перечисления условий:  
**SELECT** __*__ **FROM** *table* **WHERE** *city*='London' **OR** *city*='Barcelona';  
Можно использовать следующий вариант:  
**SELECT** __*__ **FROM** *table* **WHERE** *city* **IN** ('London', 'Barcelona');  
* **IN** полностью определяет множество, которому данное значение может принадлежать или не принадлежать.
Выполняется, если значение равно хотя бы одному элементу множества.  
***
**SELECT** __*__ **FROM** *table* **WHERE** *snum* **BETWEEN** 4 **AND** 8;  
* **BETWEEN** ... **AND**... - задает границы, в которые должно попадать значение. Границы включены.
В нем можно указывать диапазон чисел или букв (алфавитный диапазон, у него не попадают крайние элементы).  
***
**SELECT** __*__ **FROM** *table* **WHERE** (*sum* **BETWEEN** 7 **AND** 10) 
**AND** **NOT** *sum* **IN** (7, 10) - исключающее множество, в которое не входят границы.  
***
 **LIKE** применим только к полям типа **CHAR** или **VARCHAR**, поскольку он используется для поиска подстрок. Он осуществляет просмотр строки для
выяснения: входит ли заданная подстрока в указанное поле. С этой же целью используются шаблоны - специальные 
символы, которые могут обозначать все, что угодно.  
Существует два типа шаблонов, используемых с **LIКE**:  
* Символ "подчеркивание" ( **_** ) заменяет один любой символ. Например, образцу
'b_t' соответствуют 'bаt' или 'bit', но не соответствует 'brat'. 
* Символ "процент" ( **%** ) заменяет последовательность символов произвольной
длины, в том числе и нулевой. Например, образцу '%p%t' соответствуют 'put',
'posit', 'opt', но не 'spite'.  
**LIКE** может оказаться полезным при осуществлении поиска имени или другого
значения, полное написание которого неизвестно.  

**SELECT** __*__ **FROM** *table* **WHERE** *sname* **LIKE** 'G%';  

***
Специальные операторы (**IS**, **LIKE**, **BEETWEN**, **IN**, **LIKE**) могут непосредственно предшествовать булеву оператору 
**NOT**. Этим они отличаются от операторов сравнения, которые должны содержать **NOT** перед всем выражением.  

**SELECT** __*__ **FROM** *Customers* **WHERE** *city* **IS NOT NULL;**  
Эквивалентно следующему:  
**SELECT** __*__ **FROM** *Customers* **WHERE** **NOT** *city* **IS NULL;**  

**SELECT** __*__ **FROM** *Salespeople* **WHERE** *city* **NOT IN** (*'London', ·san Jose'*);  
<=>  
**SELECT** __*__ **FROM** *Salespeople* **WHERE** **NOT** *city* **IN** (*'London' , 'San Jose'*);  

***

Символ шаблона **(%)** в конце строки необходим в тех реализациях SQL, в которых длина поля sname пре­восходит количество 
букв в значении (например тип **CHAR**, где фиксированная длина строки). В этих случаях к значению в таблице добавляются 
пробелы до длины строки. 
***
Чтобы найти в строке символ подчеркивания или процента, в предикате **LIKE** любой символ можно определить как **Еsсаре-символ**. 
Он используется в предикате непо­средственно перед символом процента или подчеркивания и означает, что следующий за ним 
символ интерпретируется именно как обычный символ, а не как символ шаблона.  

**SELECT** __*__ **FROM** *table* **WHERE** *sname* **LIKE** '%/_%' **ESCAPE** '/';
  
 Предложение **ESCAPE** определяет **'/'** как Еsсаре-символ, который используется в **LIКЕ**-строке, за ним следуют
 символ процента, символ подчеркивания или сам символ **'/'**, т.е. тот символ, поиск которо­го будет осуществляться в 
 столбце и который уже не интерпретируется как символ шаблона. **Еsсаре-символ** может быть единственным символом и 
 применяться только к единственному символу, который следует за ним.  
 ***
 **NULL** - пустое значение (поле) в строке (записи).  
 Когда **NULL-значение** сравнивается с любым значением, даже с **NULL-значением**, результат просто неизвестен. 
 Булево значение "неизвестно" ведет себя также, как "ложь" - строка, на которой предикат принимает значение "неизвестно",
 не включается в результат запроса - при одном важном исключении: **NOT** от лжи есть истина (**NOT (false)=true**), 
 тогда как **NOT** от неизвестного значения есть также неизвестное значение. Следовательно, такое выраже­ние как 
 **"city = NULL"** или **"city IN (NULL)"** является неизвестным независимо от значения city.  
 
 **IS** - используется с ключевым словом **NULL** для локализации **NULL-значения**.
   
 **SELECT** __*__ **FROM** *table* **WHERE** *city* **IS** **NULL**;  
 
***
 
 ## Функции агрегирования.  
 
* **COUNT** определяет количество строк или значений поля, выбранных посредством запроса и не являющихся **NULL**-значениями.
* **SUM** вычисляет арифметическую сумму всех выбранных значений данного
поля.
* **АVG** вычисляет среднее значение для всех выбранных значений данного поля.
* **МАХ** вычисляет наибольшее из всех выбранных значений данного поля.
* **MIN** вычисляет наименьшее из всех выбранных значений данного поля.  

Функции агрегирования используются как имена полей в предложении запроса **SELECT** с одним исключением: имена полей 
применяются как аргументы.  
Для **SUM** и **AVG** могут использоваться только цифровые поля. Для **COUNT, МАХ** и **MIN** - цифровые и символьные поля.  
***
Сумма всех заявок из таблицы *Orders*:  
**SELECT SUM**(*amt*) **FROM** *Orders*;  

***
 Функция **COUNT** отличается от предыдущих тем, что подсчитывает количество значений в данном столбце или количество 
 строк в таблице. Когда подсчитываются значения по столбцу, в команде используется **DISTINCT** для подсчета числа 
 различных значений данного поля.  
 
 **SELECT** **COUNT** (**DISTINCT** *snum*) **FROM** *Orders*;  
 
 **DISТINCT** можно применять с любой функцией агрегирования, но чаще всего он используется с **COUNT**.  
 Для подсчета общего количества строк в таблице следует использовать функцию **COUNT** со звездочкой вместо имени поля.  
 
 **SELECT** **COUNT** (__*__) **FROM** *Customers*; - подсчет общего количества строк в таблице *Customers*.  

Различие между **ALL** и __*__ при использовании **COUNT** заключается в следующем:
* **ALL** использует имя поля в качестве аргумента.
* **ALL** не подсчитывает **NULL**-значения.  
 
**SELECT COUNT** (**ALL** *rating*) **FROM** *Customers*; - подсчет количества значений поля *rating*, отличных от 
**NULL**-значений, в таблице *Customers* (включая повторения).  

***
Агрегатные функции можно использовать с аргементами, состоящими из нескольких полей:  

**SELECT МАХ** (*binc + amt*) **FROM** *Orders*;  

***
**GROUP BY** группирует по полям, имеющим одинаковые значения.

**SELECT** *snum*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum*; -  наибольший заказ из тех, что получил каждый 
из продавцов.

**GROUP BY** применяет агрегатные функции отдельно к каждой серии групп, которые определяются общим значением поля. 
В данном случае каждая группа состоит из всех тех строк, которые имеют одно и то же значение *snum*, а функция **МАХ** 
применяется отдельно к каждой такой группе. Это означает, что поле, к которому применяется
**GROUP BY** по определению имеет на выходе только одно значение на каждую группу, что соответствует применению 
агрегатных функций.  

**Двойная группировка**: группировка данных таблицы *Orders* по дате (*odate*) внутри одного и того же поля **snum** и применить функцию **МАХ**
к каждой группе.  
   
 **SELECT** *snum*, *odate*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum*, *odate*;  
 
***
 
Использовать *агрегатные функции* в предложении **WHERE** **нельзя** поскольку предикаты оцениваются в терминах единственной
строки, тогда как агрегатные функции оцениваются в терминах групп строк.  

Покупки превышающие 3000 сгруппированные по датам у сгруппированных продавцов:  
**! ! ! НЕЛЬЗЯ! ! !:**  
**SELECT** *snum, odate*, **MAX**(*amt*) **FROM** *Orders* **WHERE MAX**(*amt*) > 3000.00 **GROUP ВY** *snum, odate*;  

***! ! ! МОЖНО ! ! !:**  
**SELECT** *snum, odate*, **MAX**(*amt*) **FROM** *Orders* **GROUP ВY** *snum, odate* **HAVING MAX**(*amt*) > 3000.00;  

* **HAVING** -  определяет критерий, согласно которому определенные группы исключаются из числа выходных данных, так же,
как предложение **WHERE** делает это для отдельных строк. Аргументы **HAVING** подчиняются тем же правилам, что и 
аргументы **SELECT** в команде, использующей **GROUP ВY**, и должны иметь единственное значение для каждой выходной группы.   
**HAVING** должно относиться только к агрегатам и полям, выбранным по **GROUP ВY**.  

"Вот наибольшие заявки на 3 октября":  
**SELECT** *snum*, **MAX**(*amt*) **FROM** *Orders* **WHERE** *odate* = 10/03/1990
**GROUP BY** *snum*;  

**HAVING** может иметь только такие аргументы, у которых единственное значение для группы выходных данных. На практике 
чаще всего применяются агрегатные функции, но можно осуществлять выбор полей и с помощью **GROUP ВY**. Например, можно 
взглянуть на самые большие заказы для Serres и Rifkin:  

**SELECT** *snum*, **MAX**(*amt*)  
**FROM** *Orders*  
**GROUP ВY** *snum*  
**HAVING** *snum* **IN** (1002, 1007)  

Агрегатные функции применимы к группам значений, определяемым предложением **GROUP ВY**. Эти группы имеют общее значение
поля и могут использоваться внутри других групп, имеющих общее значение поля. Предикаты нужны для определения строк, 
к которым применяется функция агрегирования. Вы можете задать условие исключения определенных результирующих
групп с помощью предложения **HAVING**.  

***
Все заявки от 10 марта 1990:  

**SELECT** **COUNT** ( __*__ )  
**FROM** *Orders*  
**WHERE** *odate* = 10/03/1990;  

***
Количество различных городов (не **NULL**) в таблице *Customers*:
  
**SELECT COUNT** (**DISTINCT** *city*)  
**FROM** *Customers*;  

***
Запрос, который выбирает первого в алфавитном порядке покупателя, имя которого начинается с 'G':

**SELECT MIN** (*cname*)  
**FROM** *Customers*  
**WHERE** *cname* **LIKE** 'G%';   

***
Запрос, который выбирает максимальный рейтинг (rating) для каждого города:  

**SELECT** *city*, **МАХ** (*rating*)  
**FROM** *Customers*  
**GROUP ВY** *city*;  
  
***
Вставка текста в новые столбцы в каждую строку выходной таблицы:  

**SELECT** 'Fог', *odate*, 'there аге',  
**COUNT** (**DISTINCT** *onum*), 'orders'  
**FROM** *Orders*  
**GROUP ВY** *odate*;  

***

### Упорядочивание выходных полей  

**SELECT** __*__  
**FROM** *Orders*  
**ORDER ВY** *cnum* **DESC**;  

* **ORDER BY** - упорядочивает в соответствии со значениями одного
или нескольких выбранных столбцов.  
    * **DESC** - убывающая сортировка.
    * **ASC** - возрастающая сортировка.  
 
 **ORDER BY** применяется только для столбцов, указанных в **SELECT**.  
 Её можно применять для любого количества столбцов:  
 
**SELECT** __*__  
**FROM** *Orders*  
**ORDER ВY** *cnum* **DESC**, *amt* **DESC**;  

**OREDRD BY** всегда выполняется последней.  

Вместо имен столбцов для указания полей, по которым упорядочиваются выходные данные, можно использовать номера. 
Но ссылаясь на них, следует иметь в виду, что это номера в определении выходных данных, а не столбцов в таблице. 
Т.е. первое поле, имя которого указано в **SELECT**, является для предложения **ORDER ВY** полем с
номером **1**, независимо от его расположения в таблице.  
Столбцы, полученные с помощью функций агрегирования, константы или выражения в предложении запроса **SELECT**, можно 
применить и с **ORDER ВY**, если на них ссылаются по номеру.  

***

## Соединение таблиц.  

### Выполнение операции соединения (join)

**SELECT** *Customers.cname, Salespeople.sname, Salespeople.city*  
**FROM** *Salespeople, Customers*  
**WHERE** *Salespeople.city = Customers.city*;  

Выполняя операцию соединения, необходимо генерировать все возможные сочетания
строк для двух или более таблиц и проверять истинность предиката на каждом таком
сочетании.  
В предыдущем примере **SQL** берет строку, соответствующую продавцу *Рееl* из таблицы *Salespeople*, и комбинирует ее 
с каждой строкой таблицы *Customers*, выбирая по одной строке из этой таблицы. Если на данной комбинации
строк предикат имеет значение "истинно", т.е. поле *city* строки таблицы Customers содержит
значение *London* такое же, как и у *Рееl*, то указанные в предложении **SELECT**
поля из комбинации этих строк являются выходными данными. Те же действия предпринимаются
относительно каждого продавца из таблицы *Salespeople*.  

### Операция соединения таблиц посредством ссылочной целостности  

Эrа операция применяется для использования связей, встроенных в базу данных. В предыдущем примере связь между таблицами 
была установлена с помощью операции соединения. Но эти таблицы уже связаны по значениям полем *snum*(присутствует в 
обеих таблицах). Такая связь называется *состоянием ссылочной целостности*. Стандартное применение операции соединения 
состоит в извлечении данных в терминах этой связи. Чтобы показать соответствие имен покупателей именам продавцов, 
обслуживающих этих покупателей, используется следующий запрос:  

**SELECT** *Customers.cname, Salespeople.sname*  
**FROM** *Customers, Salespeople*  
**WHERE** *Salespeople.snum = Customers.snum*;  

***

### Как выполняется операция соединения двух копий одной таблицы

Соединение таблицы с ее же копией означает следующее: любую строку таблицы (одну в каждый момент времени) можно 
комбинировать с ее копией и с любой другой строкой этой же таблицы. Каждая такая комбинация оценивается в терминах 
предиката, как и в случае соединения нескольких различных таблиц. Это позволяет легко конструировать определенные виды 
связей между различными записями внутри единственной таблицы - например, осуществлять поиск пар строк с общим значением 
поля.  

Синтаксис команды соединения таблицы с ее же копией тот же, что и для различных
таблиц, с единственным исключением. В рассматриваемом случае все имена
столбцов повторяются независимо от использования имени таблицы в качестве префикса.
Чтобы сослаться на столбцы запроса, нужно иметь два различных имени для
одной и той же таблицы. Для этого надо определить временные имена, называемые
*переменными области определения, переменными корреляции* или просто *алиасами*.
Они определяются в предложении запроса **FROM**. Для этого указывается имя таблицы,
ставится пробел, а затем указывается имя алиаса для данной таблицы.  

**SELECT** *first.cname, second.cname, first.rating*  
**FROM** *Customers first, Customers second*  
**WHERE** *first.rating = second.rating*;  

В данном примере задвоятся строки вывода, т.к. сначала будет для одной таблицы, затем для второй. Самое простое 
решение - это добавить операцию сравнения имен в алфавитном порядке(в одном из проходов по таблицам оно будет ложью):  

**SELECT** *first.cname, second.cname, first.rating*  
**FROM** *Customers first, Customers second*  
**WHERE** *first.rating = second.rating* **AND** *first.cname < second.cname*;  

***

### Вложенные запросы

Выбор всех заказов из таблицы *Orders* у определенного продавца. 
Известно только его имя 'Motika', но не *snum*. Поэтому подзапросом сопоставляем имя и 
*snum* в другой таблице:  

**SELECT** __*__  
**FROM** *Orders*  
**WHERE** *snum* =  
 (**SELECT** *snum* **FROM** *Salespeople* **WHERE** *sname* = 'Motika');  
 
 В случае оператора равенства в предикате, подзапрос должен возращать только одно значение. 
 В других случаях он будет признан *UNKNOWN* или ошибочным.  
 
 В некоторых случаях можно использовать **DISTINCT** для гарантии получения единственного значения в результате 
 выполнения подзапроса. Предположим, нужно найти все заказы (*orders*), с которыми работает продавец, обслуживающий 
 покупателя Hoffman (*cnum = 2001*). В подзапросе вычисляем продавца, который работает с данным покупателем, убираем 
 возможные дубликаты и передаем в основной запрос:  
 
**SELECT** __*__   
**FROM** *Orders*  
**WHERE** *snum* =  
(**SELECT** **DISTINCT** *snum* **FROM** *Orders* **WHERE** *cnum* = 2001); 
 
Предикаты, включающие подзапросы, используют форму <скалярное выражение> <оператор> <подзапрос>, а не <подзапрос>
 <оператор> <скалярное выражение> или <подзапрос> <оператор> <подзапрос>. Согласно ограничению ANSI запрещен также 
 вариант команды, в котором оба значения, участвующие в сравнении, получаются в результате выполнения подзапросов.  
 
 В подзапросах нельзя использовать **GROUP BY**, т.к. оно по умолчанию должно возвращать не единственное значение. 
 Соглашение ANSI запрещает его использовние даже с **HAVE**.  
 
 Операторы **BEETWEN, LIKE, IS NULL** в подзапросах тоже нельзя применять.  
 
 Оператор **IN** можно использовать в подзапросах. Когда **IN** применяется в подзапросе, **SQL** просто строит 
 множество значений из выходных данных подзапроса.  
 
 ***
 
 ### Подзапросы с HAVING
 Подзапросы можно применять также внутри предложения **HAVING**. В самих таких подзапросах можно использовать их 
 собственные агрегатные функции, если они не дают множества значений, а также **GROUP ВY** или **HAVING**.  

Поиск покупателей (customers) с рейтингом (raiting), превышающим среднее значение для San Jose:  
 
**SELECT** *rating*, **COUNT** (**DISTINCT** *cnum*)  
**FROM** *Customers*  
**GROUP ВY** *rating* **HAVING** *rating* >  
(**SELECT** **AVG** (*rating*) **FROM** *Customers* **WHERE** *city* = 'San Jose');  
  
 ***
 
 Запрос, который выдает имена и рейтинги всех тех покупателей, кото­рые сделали больше среднего числа заказов.  
 
 **SELECT** **DISTINCT** *cname*, *rating*  
 **FROM** *Customers*, *Orders*  
 **WHERE** *amt* >  
(**SELECT** **AVG** (*amt*) **FROM** *Ordeгs*)  
 **AND** *Orders.cnum = Customers.cnum*;  
 
 ***
 
Запрос, выбирающий сумму заказов каждого продавца, у которого она превышает наибольшее значение поля *amt* в 
таблице *Orders*.  

 **SELECT** *snum*, **SUM** (*amt*)  
 **FROM** *Orders*  
 **GROUP ВY** *snum*  **HAVING** **SUM** (*amt*) >  
 (**SELECT** **МАХ** (*amt*) **FROM** *Orders*);  
 
 ***
### Связанные подзапросы

Это когда в подзапросе используется таблица, указанная в **FROM** исходного(внешнего) запроса.   
Один из способов отыскать всех покупателей, сделавших заказы 3 октября 1990 года:  
Используются алиасы для таблиц **inner** и **outer**.
   
**SELECT** __*__ **FROM** *Customers* outer  
**WHERE** 10/03/1990 **IN**  
(**SELECT** *odate* **FROM** *Orders* inner **WHERE** *outer.cnum = inner.cnum*);  

***

Задачу выше можно было бы решить, используя операцию соединения (**join**).  

**SELECT** __*__  
**FROM** *Customers* first, *Orders* second  
**WHERE** *first.cnum = second.cnum* **AND** *second.odate* = 10/03/1990;  

Но выходные строки могут задвоиться. Этого можно избежать используя **SELECT DISTINCT** вместо **SELECT**. 
Такого не происходит при использовании подзапросов. Оператор **IN**, используемый в версии с подзапро­сами, не делает 
разницы между значениями, выбираемыми в подзапросе однажды и повторно. Следовательно, в таком варианте запроса **DISТINCT** не является необходимым.  

***
В предложении **HAVING** могут использоваться и связанные подзапросы. В этом случае необходимо ограничить внешние ссылки
 теми элементами, которые могут непосредственно применяться в самом предложении **HAVING**.  

Необходимо суммировать значения поля *amt* таблицы *Orders*, сгруппировав их по датам и исключив те дни, когда сумма 
не превышает максимальное значение, по крайней мере на 2000.00:  

**SELECT** *odate*, **SUM** (*amt*)  
**FROM** *Orders* а  
**GROUP ВY** *odate* 
**HAVING** **SUM** (*amt*) >  
(**SELECT** 2000.00 + **МАХ** (*amt*) **FROM** *Orders* b **WHERE** **a.odate = b.odate*);  
  
Подзаnрос вычисляет максимальное (**МАХ**) значение для всех строк с одной и той же датой, совпадающей с датой, 
для которой сформирована очередная группа основного запроса. Это должно быть сделано, как показано в данном примере, 
с помощью предложения **WHERE**. В самом подзапросе не должно быть предложений **GROUP ВY** и **HAVING**.  

***

Запишите команду **SELECT**, использующую связанные подзапросы и выбираю­щую имена и номера всех покупателей, рейтинг 
которых совпадает с максималь­ным значением рейтинга для их города.  

**SELECT** *cnum*, *cname*  
**FROM** *Customers* outer  
**WHERE** *rating* =  
(**SELECT** **МАХ** (*rating*) **FROM** *Customers* inner **WHERE** *inner.city=outer.city*);  
 
 ***

### Оператор EXISTS  
 
**EXISTS** - оператор, генерирующий значение "истина" или "ложь". Используя подзапрос в качестве аргумента, этот 
оператор оценивает его как истинный, если он генерирует выходные данные, а в противном случае как ложный. В отличие от 
прочих операторов и предикатов, он не может принимать значение *unknown*.  

***

Нужно извлечь данные из таблицы *Customers* в том случае, если один (или более) покупатель из нее находится в San Jose.  

**SELECT** *cnum*, *cname*, *city*  
**FROM** *Customers*  
**WHERE** **EXISTS**  
(**SELECT** __*__ **FROM** *Customers* **WHERE** *city* = 'san Jose');  

Подзапрос (не являющийся связанным) выполняется только один раз для всего внешнего запроса и, следовательно, имеет 
единственное значение для всех случаев.
  
***
    
При применении связанных подзапросов предложение **EXISTS**, как и другие предикатные операторы, оценивается отдельно 
для каждой строки таблицы, на которую есть ссьmка во внешнем запросе. Это позволяет использовать **EXISTS** как 
правильный предикат, генерирующий различные ответы для каждой строки таблицы, на которую есть ссылка в основном запросе.
Следовательно, при таком способе применения **EXIST** информация из внутреннего запроса сохраняется, если 
непосредственно не выводится.  

Запрос на поиск тех продавцов, которые имеют нескольких покупателей.  

**SELECT** **DISTINCT** *snum*  
**FROM** *Customers* outer  
**WHERE** **EXISTS**  
(**SELECT** __*__ **FROM** *Customers* inner **WHERE** *inner.snum = outer.snum* **AND** *inner.cnum <> outer.cnum*);  

***

### Комбинирование EXISTS и соединений 

Иногда кроме номера требуется получить о каждом продавце больше информации. Это можно сделать соединением таблиц 
*Customers* и *Salespeople*.  

**SELECT** **DISTINCT** *first.snum, sname, first.city*  
**FROM** *Salespeople* first, *Customers* second  
**WHERE** **EXISTS**  
(**SELECT** __*__ **FROM** *Customers* third **WHERE** *second.snum = third.snum* **AND** *second.cnum <> third.cnum*)  
**AND** *first.snum = second.snum*;  
 
***
 
**EXISTS** часто используется освместно с **NOT**.  

Один из способов поиска всех продавцов, имеющих только одного покупателя:  

**SELECT** **DISTINCT** *snum*  
**FROM** *Customers* outer  
**WHERE NOT EXISTS**  
(**SELECT** __*__ **FROM** *Customers* inner **WHERE** *inner.snum = outer.snum* **AND** *inner.cnum <> outer.cnum*);  
 
***

Пример, в котором извлекаются строки для всех продавцов, имеющих покупателей, сделавших более одного заказа.  

**SELECT** __*__  
**FROM** *Salespeople* first  
**WHERE** **EXISTS**  
(**SELECT** __*__  
**FROM** *Customers* second  
**WHERE** *first.snum = second.snum*  
**AND** 1 <  (**SELECT COUNT**(__*__) **FROM** *Orders* **WHERE** *Orders.cnum = second.cnum*));   

***

Запрос с **EXISTS** для того, чтобы извлечь всех продавцов, имеющих покупателей с рейтингом, превышающим 300.  

**SELECT** __*__  
**FROM** *Salespeople* first  
**WHERE EXISTS**  
(**SELECT** __*__ **FROM** *Customers* second **WHERE** *first.snum = second.snum* **AND** *rating* = 300);  

***

Решение предыдущего, применяя соединение.

**SELECT** *a.snum, sname, a.city, comm*  
**FROM** *Salespeople* а, Customers* b  
**WHERE** *a.snum = b.snum* **AND** *b.rating* = 300;  

***

## Специальные операторы ANY, SOME, ALL

**ANY**, **ALL** и **SOME** так же, как и **EXISTS**, используют в качестве аргументов подзапросы; однако, от **EXISTS** 
они отличаются тем, что применяются в конъюнкции с операторами отношения. В этом плане они сходны с оператором **IN**, 
т.е. берут все значения, полученные в подзапросе и рассматривают их как единое целое. Однако, в отличие от **IN**, 
их можно применять только с подзапросами.  

**ANY** и **SOME** абсолютно одинаковы и взаимозаменяемые.  

***

### ANY

Найти продавцов с покупателями, находящимися в одних городах.    

**SELECT** __*__  
**FROM** *Salespeople*  
**WHERE** *city* = **ANY** (**SELECT** *city* **FROM** *Customers*);  

Оператор **ANY** берет все значения поля *city* в таблице *Customers*, полученные в подзапросе, и оценивает результат 
как истину, если какое-либо (**ANY**) значение совпадает со значением поля *city* из текущей строки внешнего запроса.  

***

Любой запрос, сформулированный с **ANY** (или с **ALL**), можно сформулировать и с **EXISTS**, хотя обратное утверждение
неверно. Строго говоря, версии с **EXISTS** не совсем идентичны версиям с **ANY** или **ALL**. Различие заключается в 
обработке **NULL**-значений.  

**ANY** и **ALL** могут, по крайней мере теоретически, быть более эффективными по сравнению с **EXISTS**. Подзапрос 
с **ANY** или **ALL** можно выполнять один раз для каждой строки основного запроса и предоставлять выходные данные для 
определения предиката. С другой стороны, **EXISTS** использует связанный подзапрос, который требует повторного 
выполнения всего подзапроса для каждой строки основного запроса. **SQL** пытается найти наиболее эффектив­ный способ 
выполнения любой команды, поэтому он может пытаться преобразовать менее действенную формулировку запроса в более 
эффективную.
 
***

**ANY** оценивается как истина, если подзапрос находит *любое* (**апу**) значение (любые значения), удовлетворяющее 
(удовлетворяющие) условию.  


 **ANY** не является полностью интуитивно очевидным. Если запрос формулируется для выбора покупателей, имеющих рейтинг, 
 превышающий рейтинг любого покупателя в *Rome*, можно получить выходные данные, которые отличаются от ожидаемых.  
 
**SELECT** __*__  
**FROM** *Customers*  
**WHERE** *rating* > **ANY**  
(**SELECT** *rating* **FROM** *Customers* **WHERE** *city* = 'Rome');  
 
 Если бы **ANY** интерпретировалось как обычное слово английского языка, покупатели с рейтингом 300 оказались бы выше 
 *Giovanni*, находящегося в *Rome* и имеющего рейтинг 200. Однако, подзапрос с **ANY** находит также и *Periera* из 
 *Rome* с рейтингом 100. Все покупатели с рейтингом 200 были выбраны (поскольку их рейтинги превышают 100) несмотря 
 на то, что в *Rome* был другой покупатель (*Giovanni*), рейтинг которого выше 200 (то, что один из выбранных 
 покупателей тоже находится в *Rome*, здесь значения не имеет). Они были выбраны, поскольку подзапрос сгенерировал 
 значение, сделавшее предикат истинным для этих строк.  
 
 ***
 
Можно использовать **ANY** с другими **SQL**-средствами, например, с соединениями. Этот запрос отыскивает все заказы, 
величина которых меньше величины заказа любого покупателя в *San Jose*.  
 
**SELECT** __*__  
**FROM** *Orders*  
**WHERE** *amt* < **ANY**  
(**SELECT** *amt* **FROM** *Orders* a,*Customers* b **WHERE** *a.cnum = b.cnum* **AND** *b.city = 'San Jose'*);  

***

Легко запомнить, что **< ANY** означает *"меньше, чем наибольшее выбранное значение"*, а **> ANY** означает 
*"больше, чем наименьшее выбранное значение"*.  

***
 
### ALL

Предикат с **ALL** принимает значение "истина", если каждое (every) значение, выбранное в процессе выполнения 
подзапроса, удовлетворяет условию, заданному в предикате внешнего запроса.  

Если бы было нужно, чтобы в предыдущем примере в состав выходных данных включались только те покупатели, рейтинг которых
превышает рейтинг каждого покупателя в *Rome*, то необходимо было бы ввести следующую команду для получения результата.  
 
**SELECT** __*__  
**FROM** *Customers*  
**WHERE** *rating* > **ALL**  
(**SELECT** *rating* **FROM** *Customers* **WHERE** *city* = 'Rome');  

***

**ALL** можно эффективно использовать с неравенствами, то есть с оператором **<>**. Однако, фраза "значение неравно всем
результатам подзапроса" выражается не так, как в привычном английском языке. Если подзапрос генерирует множество 
различных значений, как чаще всего это и бывает, то никакое одно значение не может бьть равно всем значениям в обычном 
смысле. В SQL **<> ALL** реально означает "не равно ни одному" из результатов подзапроса. Другими словами, предикат 
имеет значение истина, если значение не принадлежит множеству результатов подзапроса.  

***

Важное различие между **ALL** и **ANY** заключается в их реакции на ситуацию, когда подзапрос не генерирует никакого 
значения. Когда правильный подзапрос не генерирует выходных данных, **ALL** автоматически принимает значение "истина", 
а **ANY** -"ложь".  

В таком случае, если (..) получается пустым, то:
  
**WHERE** *rating* > **ANY** (..) - не генерирует выходных данынх  
**WHERE** *rating* > **ALL** (..) - полностью воспроизведет таблицу внешнего запроса  

***

## Объединение запросов UNION

Объединения (unions) отличаются от подзапросов тем, что любой из двух (или большего числа) запросов не может управлять
другим запросом. В объединении все запросы выполняются независимо, но их выходные данные затем объединяются.  

**UNION** объединяет выходные данные двух или более SQL-запросов в единое множество строк и столбцов. Для того чтобы 
получить сведения обо всех продавцах (salespeople) и покупателях (customers) Лондона в виде выходных данных одного 
запроса, следует ввести:  

**SELECT** *snum*, *sname*  
**FROM** *Salespeople*  
**WHERE** *city* = 'London'  
**UNION**  
**SELECT** *cnum*, *cname*  
**FROM** *Customers*  
**WHERE** *city* = 'London·;  

Стоблцы объединяемых запросов должны быть *сравнимы* - иметь один тип и размер, и их должно быть одинаковое количество.  

Нельзя использовать **UNION** в подзапросах также, как и функции агрегирования в предложениях **SELECT** запросов в 
объединении.  

**UNION** автоматически исключает из выходных данных дублирующиеся строки.

***

**ORDER ВY** применяется и для упорядочения выходных данных объединения, так же как это делалось для отдельных 
(индивидуальных) запросов.  

Т.к. в выводе **UNION** столцбы не имеют имен, то в **ORDER BY** указыватся номера стобцов для группировки.  

***

## Ввод, изменение и удаление значений

### Ввод значений

Все строки в SQL вводятся при помощи команды обновления **INSERT**. В простейшем случае команда **INSERT** имеет такой 
синтаксис:  

**INSERT** **INTO** *<имя таблицы>* **VALUES** (*<значение>,<значение> ... *);  

***

Вставка строки в таблицу *Salespeople*:  

**INSERT** **INTO** *Salespeople* **VALUES** (*1001, "Peel", "London',.12*);  

***

### Вставка NULL-значений

Если нужно вставить **NULL**-значение, необходимо указать его как обычное зна­чение.  

**INSERT** **INTO** *Salespeople* **VALUES** (*1001, 'Peel',* **NULL**,*.12*);

Поскольку **NULL** является специальным символом, а не символьным значением, оно указано без одиночных кавычек. 

***

### Именование столбцов для INSERT

Для указания имен столбцов, в которые необходимо ввести значения, порядок столбцов в таблице неважен.  

**INSERT** **INTO** *Customers* (*city, cname, cnum*) **VALUES** (*'London, 'Hoffman, 2001*);  
  
Столбцы с именами *rating* и *snum* опущены. Это означает, что для каждого из них автоматически назначаются значения 
по умолчанию. По умолчанию может быть установлено либо значение **NULL**, либо вполне определенное значение.  

***

### Вставка результатов запроса

Команду **INSERT можно** применить для того, чтобы извлечь значения из одной таблицы и разместить их в другой, 
воспользовавшись для этого запросом. Для этого достаточно заменить предложение **VALUES** на соответствующий запрос:  

**INSERT** **INTO** *Londonstaff*  
**SELECT** __*__  
**FROM** *Salespeople*  
**WHERE** *city* = 'London';  
 
***

Вставка в отдельную таблицу суммы заказов по дням:  

**INSERT** **INTO** *Daytotals* (*date, total*)  
**SELECT** *odate*, **SUM** (*amt*)  
**FROM** *Orders*  
**GROUP ВY** *odate*;  

***

### Исключение строк из таблицы

Строки из таблицы можно исключить с помощью команды обновления **DELETE**. По этой команде исключаются только целые 
строки, а не отдельные значения полей. Таким образом имя поля не является аргументом, необходимым для выполнения 
команды, и воспринимается как ошибочный аргумент. Для исключения всех строк таблицы *Salespeople*, следует ввести 
следующее предложение:  

**DELEТE** **FROM** *Salespeople*;  

В результате выполнения этой команды таблица становится пустой и ее можно удалить по команде **DROP TABLE**.  

***

Обычно из таблицы требуется удалить только некоторые указанные строки. Чтобы их определить, можно, как и для запросов, 
использовать предикат. Например, чтобы исключить продавца *Axelrod* из таблицы, следует ввести:  

**DELEТE** **FROM** *Salespeople*  
**WHERE** *snum* = 1003;  

Поле *sпum* используется вместо поля *sпame*, поскольку наилучший способ при удалении единственной строки -это указать 
значение ее первичного ключа. Применение первичного ключа гарантирует удаление единственной строки. Можно употребить и 
предикат, выбирающий группу строк, например:  

**DELETE** **FROM** *Salespeople*  
**WHERE** *city* = 'London';  

***

### Изменение значений полей

**UPDATE** изменяет значение некоторые или все значения в строке.  
**SET** определяет изменение, которое надо выполнить для определенного столбца. 

Изменение рейтинга всех покупателей:  

**UPDATE** *Customers*  
**SET** *rating* = 200;  

***

Изменение значений в конкретных строках:  

**UPDATE** *Customers*  
**SЕТ** *rating* = 200  
**WHERE** *snum* = 1001;  

***

В предложении **SET** можно указать любое количество значений для столбцов, разделенных запятыми. Все указанные 
изменения выполняются для каждой строки таблицы, удовлетворяющей предикату. В каждый момент времени обрабатывается 
одна строка таблицы.  

**UPDATE** *Salespeople*  
**SET** *sname* = 'Gibson', *city* = 'Boston', 'comm' = .10  
**WHERE** *snum* = 1004;  

В результате выполнения команды все покупатели продавца *Motika* со своими заказами перейдут к *Gibson*, поскольку они 
связаны с *Motika* по значению поля *snum*.  

***

Нельзя обновить множество таблиц с помощью одной команды, т.к. в **SET** нельзя использовать имя таблицы в качестве 
префикса имени столбца.  

***

В предложении **SET** команды **UPDATE** можно использовать скалярные выражения, указывающие способ изменения значений 
поля в отличие от предложения **VALUES** команды **INSERT**, в котором нельзя использовать выражения. Это весьма 
полезная характеристика. Предположим, решено удвоить комиссионные продавцов. Можно использовать следующее выражение:  

**UPDATE** *Salespeople*  
**SЕТ** *comm* = *comm**2;  

***

Можно комбинировать отдельные компоненты предложения **UPDATE**. Можно изменить значение комиссионных только для 
продавцов из Лондона с помощью предложения:  

**UPDATE** *Salespeople*  
**SET** *comm* = *comm**2  
**WHERE** *city* = 'London';  

***

### Подзапросы в INSERT

Подзапрос, для того чтобы добавить в таблицу *SJpeople* всех продавцов, имеющих покупателей в *San Jose*, независимо от 
места проживания продавца:  

**INSERT** **INTO** *SJpeople*  
**SELECT** __*__   
**FROM** *Salespeople*  
**WHERE** *snum* = **ANY**  
(**SELECT** *snum* **FROM** *Customers* **WHERE** *city*='San Jose');  

***

На таблицу, которая правится в **INSERT**, нельзя ссылаться в подзапросах.  

***

Назначено вознаграждение для каждого продавца, имеющего максимальный заказ на каждый день. Сведения о них можно 
формировать в таблице *Bonus*, содержащей значение поля *snum* для продавца, дату (*odate*) и объем 
заказа (*amount, amt*).  

**INSERT** **INTO** *Bonus*  
**SELECT** *snum, odate, amt*  
**FROM** *Orders* а  
**WHERE** *amt* =  
(**SELECT МАХ** (*amt*) **FROM** *Оrders* b **WHERE** *a.odate = b.odate*);  

Несмотря на то, что команда имеет подзапрос, базирующийся на той же таблице, что и внешний запрос, она не ссылается на 
таблицу *Bonus*, на которую воздействует эта команда. Следовательно, ее можно использовать.  

***

### Подзапросы в DELETE

В предикате команды **DELETE** можно использовать подзапросы.  

Если необходимо закрыть лондонский офис, можно использовать следующий запрос для исключения всех покупателей, 
назначенных продавцам в *London*:  

**DELEТE**  
**FROM** *Customers*  
**WHERE** *snum* = **ANY**  
(**SELECT** *snum* **FROM** *Salespeople* **WHERE** *city* = 'London');  


  